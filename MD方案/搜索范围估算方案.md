# 基于资源曲线的智能搜索范围估算方案

## 一、核心思路

根据各区域的资源特性（风能、光能、生物质、负荷），智能估算设备配置的合理搜索范围，大幅减少搜索空间。

```
搜索空间优化流程：
┌─────────────────────────────────────────────────────────────────┐
│  原始搜索空间: 7500万组合                                        │
│                    ↓                                            │
│  Step 1: 确定生物质路线 (3选1) → 减少67%                         │
│                    ↓                                            │
│  Step 2: 根据负荷估算装机范围 → 减少90%                          │
│                    ↓                                            │
│  Step 3: 根据资源可用性剪枝 → 减少80%                            │
│                    ↓                                            │
│  最终搜索空间: 约5000-10000组合 (可在10秒内完成)                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 二、各区域资源特性汇总

### 2.1 区域类型资源矩阵

| 区域类型 | 日用电(MWh) | 峰值负荷(MW) | 风速(m/s) | 光照系数 | 生物质(t/d) | 热值(MJ/kg) |
|---------|------------|-------------|----------|---------|------------|------------|
| 工业区 | 1320 | 65 | 4.0 | 1.0 | 60 | 10.3 |
| 居民区 | 660 | 35 | 3.5 | 1.0 | 80 | 11.2 |
| 山地区 | 120 | 8 | 7.5 | 1.2 | 30 | 15.1 |
| 农业区 | 240 | 12 | 5.0 | 1.1 | 100-350* | 16.0 |
| 林业区 | 72 | 4 | 1.5 | 0.7 | 150 | 17.7 |

*农业区8-10月丰收季产量350t/d，其他月份100t/d

### 2.2 各区域发电潜力估算

```typescript
// 发电潜力计算公式
interface RegionPotential {
  windPotential: number;      // 风电潜力 MWh/MW装机/年
  solarPotential: number;     // 光伏潜力 MWh/MW装机/年
  biomassPotential: number;   // 生物质发电潜力 MWh/年
}

const REGION_POTENTIAL: Record<CityType, RegionPotential> = {
  '工业区': {
    windPotential: 2000,      // 年利用2000小时
    solarPotential: 1200,     // 年利用1200小时
    biomassPotential: 17082   // 60t/d × 365 × 0.78MWh/t
  },
  '居民区': {
    windPotential: 1800,
    solarPotential: 1200,
    biomassPotential: 25112   // 80t/d × 365 × 0.86MWh/t
  },
  '山地区': {
    windPotential: 2500,      // 风资源好
    solarPotential: 1400,     // 高海拔光照强
    biomassPotential: 12812   // 30t/d × 365 × 1.17MWh/t
  },
  '农业区': {
    windPotential: 2200,
    solarPotential: 1300,
    biomassPotential: 73656   // 平均163t/d × 365 × 1.24MWh/t
  },
  '林业区': {
    windPotential: 1500,      // 风资源差
    solarPotential: 1000,     // 树冠遮挡
    biomassPotential: 76650   // 150t/d × 365 × 1.40MWh/t
  }
};
```

---

## 三、搜索范围估算算法

### 3.1 Step 1: 确定生物质技术路线

根据区域生物质特性自动推荐最优路线：

```typescript
interface BiomassRouteRecommendation {
  route: '直燃' | '气化' | '沼气';
  reason: string;
  efficiency: number;
  suitability: number;  // 0-100分
}

function recommendBiomassRoute(region: Region): BiomassRouteRecommendation[] {
  const comp = region.biomassComp;
  const dailyOutput = region.resource.biomass.baseOutput;
  
  const recommendations: BiomassRouteRecommendation[] = [];
  
  // 直燃路线评估
  // 适合：大规模、含水率适中、热值高
  const directScore = calculateDirectScore(comp, dailyOutput);
  recommendations.push({
    route: '直燃',
    reason: dailyOutput > 50 ? '产量大，适合规模化直燃' : '产量较小，直燃效率偏低',
    efficiency: 0.28,
    suitability: directScore
  });
  
  // 气化路线评估
  // 适合：中小规模、含水率低、粒度可控
  const gasificationScore = calculateGasificationScore(comp, dailyOutput);
  recommendations.push({
    route: '气化',
    reason: comp.Moisture < 25 ? '含水率低，气化效率高' : '含水率偏高，需预干燥',
    efficiency: 0.25,
    suitability: gasificationScore
  });
  
  // 沼气路线评估
  // 适合：含水率高、有机质丰富、畜禽粪便
  const biogasScore = calculateBiogasScore(comp, dailyOutput);
  recommendations.push({
    route: '沼气',
    reason: comp.Moisture > 30 ? '含水率高，适合厌氧发酵' : '含水率低，需补水',
    efficiency: 0.30,
    suitability: biogasScore
  });
  
  return recommendations.sort((a, b) => b.suitability - a.suitability);
}

// 各路线评分细则
function calculateDirectScore(comp: BiomassComposition, dailyOutput: number): number {
  let score = 50;
  
  // 产量评分 (20分)
  if (dailyOutput >= 100) score += 20;
  else if (dailyOutput >= 50) score += 15;
  else if (dailyOutput >= 30) score += 10;
  else score += 5;
  
  // 含水率评分 (15分) - 直燃适合30-50%
  if (comp.Moisture >= 20 && comp.Moisture <= 45) score += 15;
  else if (comp.Moisture < 20) score += 10;  // 太干，燃烧过快
  else score += 5;  // 太湿，效率低
  
  // 灰分评分 (15分) - 灰分低更好
  if (comp.Ash < 10) score += 15;
  else if (comp.Ash < 20) score += 10;
  else score += 5;
  
  return Math.min(100, score);
}

function calculateGasificationScore(comp: BiomassComposition, dailyOutput: number): number {
  let score = 50;
  
  // 产量评分 (20分) - 气化适合中小规模
  if (dailyOutput >= 30 && dailyOutput <= 150) score += 20;
  else if (dailyOutput < 30) score += 15;
  else score += 10;  // 大规模气化成本高
  
  // 含水率评分 (15分) - 气化需要低含水率
  if (comp.Moisture < 20) score += 15;
  else if (comp.Moisture < 30) score += 10;
  else score += 0;  // 含水率高不适合气化
  
  // 挥发分评分 (15分) - 高挥发分利于气化
  if (comp.Volatiles > 60) score += 15;
  else if (comp.Volatiles > 50) score += 10;
  else score += 5;
  
  return Math.min(100, score);
}

function calculateBiogasScore(comp: BiomassComposition, dailyOutput: number): number {
  let score = 50;
  
  // 产量评分 (20分)
  if (dailyOutput >= 50) score += 20;
  else if (dailyOutput >= 30) score += 15;
  else score += 10;
  
  // 含水率评分 (15分) - 沼气适合高含水率
  if (comp.Moisture > 35) score += 15;
  else if (comp.Moisture > 25) score += 10;
  else score += 5;  // 太干需补水
  
  // C/N比评分 (15分) - 理想C/N比20-30
  const cnRatio = comp.C / Math.max(comp.N, 0.1);
  if (cnRatio >= 20 && cnRatio <= 30) score += 15;
  else if (cnRatio >= 15 && cnRatio <= 40) score += 10;
  else score += 5;
  
  return Math.min(100, score);
}
```

### 3.2 各区域推荐路线

| 区域类型 | 推荐路线 | 适合度 | 原因 |
|---------|---------|-------|------|
| 工业区 | 沼气 > 直燃 | 75/60 | 含水率高(40%)，适合厌氧发酵 |
| 居民区 | 沼气 > 直燃 | 70/55 | 含水率高(35%)，生活垃圾适合发酵 |
| 山地区 | 气化 > 直燃 | 80/65 | 含水率低(20%)，灌木适合气化 |
| 农业区 | 直燃 > 气化 | 85/75 | 产量大，秸秆适合直燃 |
| 林业区 | 直燃 > 气化 | 90/80 | 产量大，木屑热值高，最适合直燃 |

---

### 3.3 Step 2: 根据负荷估算装机范围

```typescript
interface CapacityRange {
  min: number;
  max: number;
  step: number;
  recommended: number;
}

interface EquipmentRanges {
  wind: CapacityRange;      // MW
  solar: CapacityRange;     // MW
  biomass: CapacityRange;   // MW
  battery: CapacityRange;   // MWh
}

function estimateCapacityRanges(region: Region): EquipmentRanges {
  const dailyLoad = calculateDailyLoad(region);      // MWh
  const peakLoad = calculatePeakLoad(region);        // MW
  const annualLoad = dailyLoad * 365;                // MWh
  
  // 风电装机估算
  const windPotential = REGION_POTENTIAL[region.type].windPotential;
  const windCapacityForFullSupply = annualLoad / windPotential;  // 满足全年负荷所需装机
  
  // 光伏装机估算
  const solarPotential = REGION_POTENTIAL[region.type].solarPotential;
  const solarCapacityForFullSupply = annualLoad / solarPotential;
  
  // 生物质装机估算（基于可用原料）
  const biomassPotential = REGION_POTENTIAL[region.type].biomassPotential;
  const biomassCapacity = biomassPotential / 8000;  // 年运行8000小时
  
  // 储能容量估算（覆盖4-8小时峰值负荷）
  const batteryCapacity = peakLoad * 6;  // 6小时储能
  
  return {
    wind: {
      min: 0,
      max: Math.ceil(windCapacityForFullSupply * 1.5),  // 上限为满供的150%
      step: calculateStep(windCapacityForFullSupply),
      recommended: Math.round(windCapacityForFullSupply * 0.3)  // 推荐30%风电占比
    },
    solar: {
      min: 0,
      max: Math.ceil(solarCapacityForFullSupply * 1.5),
      step: calculateStep(solarCapacityForFullSupply),
      recommended: Math.round(solarCapacityForFullSupply * 0.3)
    },
    biomass: {
      min: 0,
      max: Math.ceil(biomassCapacity * 1.2),  // 不超过原料供应能力
      step: calculateStep(biomassCapacity),
      recommended: Math.round(biomassCapacity * 0.8)
    },
    battery: {
      min: peakLoad * 2,   // 最少2小时储能
      max: peakLoad * 12,  // 最多12小时储能
      step: peakLoad,
      recommended: peakLoad * 6
    }
  };
}

function calculateStep(capacity: number): number {
  if (capacity < 1) return 0.1;
  if (capacity < 10) return 0.5;
  if (capacity < 50) return 2;
  if (capacity < 200) return 5;
  return 10;
}
```

### 3.4 各区域装机范围估算

#### 工业区（日用电1320 MWh，峰值65 MW）

| 设备类型 | 最小 | 最大 | 步长 | 推荐值 | 搜索点数 |
|---------|-----|-----|-----|-------|---------|
| 风电(MW) | 0 | 100 | 5 | 20 | 21 |
| 光伏(MW) | 0 | 165 | 5 | 33 | 34 |
| 生物质(MW) | 0 | 3 | 0.5 | 2 | 7 |
| 储能(MWh) | 130 | 780 | 65 | 390 | 11 |

搜索空间：21 × 34 × 7 × 11 = **54,978**

#### 居民区（日用电660 MWh，峰值35 MW）

| 设备类型 | 最小 | 最大 | 步长 | 推荐值 | 搜索点数 |
|---------|-----|-----|-----|-------|---------|
| 风电(MW) | 0 | 55 | 2 | 11 | 28 |
| 光伏(MW) | 0 | 82 | 2 | 16 | 42 |
| 生物质(MW) | 0 | 4 | 0.5 | 3 | 9 |
| 储能(MWh) | 70 | 420 | 35 | 210 | 11 |

搜索空间：28 × 42 × 9 × 11 = **116,424**

#### 山地区（日用电120 MWh，峰值8 MW）

| 设备类型 | 最小 | 最大 | 步长 | 推荐值 | 搜索点数 |
|---------|-----|-----|-----|-------|---------|
| 风电(MW) | 0 | 7 | 0.5 | 1.5 | 15 |
| 光伏(MW) | 0 | 13 | 0.5 | 2.5 | 27 |
| 生物质(MW) | 0 | 2 | 0.2 | 1.3 | 11 |
| 储能(MWh) | 16 | 96 | 8 | 48 | 11 |

搜索空间：15 × 27 × 11 × 11 = **49,005**

#### 农业区（日用电240 MWh，峰值12 MW）

| 设备类型 | 最小 | 最大 | 步长 | 推荐值 | 搜索点数 |
|---------|-----|-----|-----|-------|---------|
| 风电(MW) | 0 | 16 | 1 | 3 | 17 |
| 光伏(MW) | 0 | 28 | 1 | 5.5 | 29 |
| 生物质(MW) | 0 | 11 | 1 | 7 | 12 |
| 储能(MWh) | 24 | 144 | 12 | 72 | 11 |

搜索空间：17 × 29 × 12 × 11 = **65,076**

#### 林业区（日用电72 MWh，峰值4 MW）

| 设备类型 | 最小 | 最大 | 步长 | 推荐值 | 搜索点数 |
|---------|-----|-----|-----|-------|---------|
| 风电(MW) | 0 | 7 | 0.5 | 1.5 | 15 |
| 光伏(MW) | 0 | 11 | 0.5 | 2 | 23 |
| 生物质(MW) | 0 | 12 | 1 | 8 | 13 |
| 储能(MWh) | 8 | 48 | 4 | 24 | 11 |

搜索空间：15 × 23 × 13 × 11 = **49,335**

---

### 3.5 Step 3: 设备型号选择策略

不需要遍历所有设备型号组合，而是根据装机容量自动匹配最优设备：

```typescript
interface EquipmentSelection {
  model: string;
  count: number;
  totalCapacity: number;
  totalCost: number;
}

function selectOptimalEquipment(
  targetCapacity: number,
  equipmentList: any[],
  capacityKey: string,
  priceKey: string
): EquipmentSelection[] {
  // 按单位容量成本排序（性价比优先）
  const sorted = [...equipmentList].sort((a, b) => 
    (a[priceKey] / a[capacityKey]) - (b[priceKey] / b[capacityKey])
  );
  
  const selections: EquipmentSelection[] = [];
  let remainingCapacity = targetCapacity;
  
  for (const equipment of sorted) {
    if (remainingCapacity <= 0) break;
    
    const unitCapacity = equipment[capacityKey];
    const count = Math.ceil(remainingCapacity / unitCapacity);
    
    // 检查是否合理（不要用太多小设备）
    if (count > 50 && sorted.indexOf(equipment) < sorted.length - 1) {
      continue;  // 跳过，尝试更大的设备
    }
    
    selections.push({
      model: equipment.model,
      count: count,
      totalCapacity: count * unitCapacity,
      totalCost: count * equipment[priceKey]
    });
    
    remainingCapacity -= count * unitCapacity;
  }
  
  return selections;
}

// 示例：选择风机
function selectWindTurbines(targetMW: number): EquipmentSelection[] {
  // 根据目标容量选择合适的风机型号
  if (targetMW < 0.1) return [];
  
  if (targetMW < 0.5) {
    // 小于500kW，使用小型风机
    return selectFromRange(WIND_TURBINES.filter(w => w.ratedPower <= 50), targetMW * 1000);
  } else if (targetMW < 5) {
    // 500kW-5MW，使用中型风机
    return selectFromRange(WIND_TURBINES.filter(w => w.ratedPower >= 50 && w.ratedPower <= 1500), targetMW * 1000);
  } else {
    // 大于5MW，使用大型风机
    return selectFromRange(WIND_TURBINES.filter(w => w.ratedPower >= 1500), targetMW * 1000);
  }
}
```

---

## 四、完整搜索流程

```typescript
async function findOptimalSolution(region: Region): Promise<Solution[]> {
  const solutions: Solution[] = [];
  
  // Step 1: 确定生物质路线（3选1）
  const biomassRoutes = recommendBiomassRoute(region);
  const selectedRoute = biomassRoutes[0];  // 选择最优路线
  
  // Step 2: 估算装机范围
  const ranges = estimateCapacityRanges(region);
  
  // Step 3: 遍历搜索空间
  for (let windMW = ranges.wind.min; windMW <= ranges.wind.max; windMW += ranges.wind.step) {
    for (let solarMW = ranges.solar.min; solarMW <= ranges.solar.max; solarMW += ranges.solar.step) {
      for (let biomassMW = ranges.biomass.min; biomassMW <= ranges.biomass.max; biomassMW += ranges.biomass.step) {
        for (let batteryMWh = ranges.battery.min; batteryMWh <= ranges.battery.max; batteryMWh += ranges.battery.step) {
          
          // 快速可行性检验
          const totalCapacity = windMW + solarMW + biomassMW;
          const peakLoad = calculatePeakLoad(region);
          
          // 剪枝1: 总装机容量必须大于峰值负荷的80%
          if (totalCapacity < peakLoad * 0.8) continue;
          
          // 剪枝2: 储能容量必须能覆盖至少2小时峰值负荷
          if (batteryMWh < peakLoad * 2) continue;
          
          // 剪枝3: 生物质装机不能超过原料供应能力
          const maxBiomassMW = calculateMaxBiomassPower(region, selectedRoute.route);
          if (biomassMW > maxBiomassMW) continue;
          
          // 选择具体设备型号
          const windEquipment = selectWindTurbines(windMW);
          const solarEquipment = selectSolarPanels(solarMW);
          const biomassEquipment = selectBiomassEquipment(biomassMW, selectedRoute.route);
          const batteryEquipment = selectBatteries(batteryMWh);
          const inverterEquipment = selectInverters(solarMW);
          
          // 构建配置
          const config: EquipmentConfig = {
            wind: windEquipment,
            solar: solarEquipment,
            biomass: biomassEquipment,
            battery: batteryEquipment,
            inverter: inverterEquipment,
            biomassRoute: selectedRoute.route
          };
          
          // 8760小时仿真验证
          const simulation = simulate8760Hours(config, region);
          
          if (simulation.feasible) {
            const cost = calculateTotalCost(config);
            solutions.push({
              config,
              cost,
              reliability: simulation.reliability,
              curtailment: simulation.curtailmentRate,
              simulation
            });
          }
        }
      }
    }
  }
  
  // 按成本排序
  return solutions.sort((a, b) => a.cost - b.cost);
}
```

---

## 五、性能优化策略

### 5.1 并行计算

```typescript
// 使用Web Worker并行计算
async function parallelSearch(region: Region): Promise<Solution[]> {
  const ranges = estimateCapacityRanges(region);
  const biomassRoute = recommendBiomassRoute(region)[0].route;
  
  // 将搜索空间分割为多个子任务
  const windSteps = generateSteps(ranges.wind);
  const workerCount = navigator.hardwareConcurrency || 4;
  const chunkSize = Math.ceil(windSteps.length / workerCount);
  
  const workers: Worker[] = [];
  const promises: Promise<Solution[]>[] = [];
  
  for (let i = 0; i < workerCount; i++) {
    const windChunk = windSteps.slice(i * chunkSize, (i + 1) * chunkSize);
    
    const worker = new Worker('optimizationWorker.js');
    workers.push(worker);
    
    promises.push(new Promise((resolve) => {
      worker.onmessage = (e) => resolve(e.data);
      worker.postMessage({
        region,
        windRange: windChunk,
        solarRange: ranges.solar,
        biomassRange: ranges.biomass,
        batteryRange: ranges.battery,
        biomassRoute
      });
    }));
  }
  
  const results = await Promise.all(promises);
  workers.forEach(w => w.terminate());
  
  // 合并结果并排序
  return results.flat().sort((a, b) => a.cost - b.cost);
}
```

### 5.2 缓存机制

```typescript
// 缓存已计算的区域最优解
const solutionCache = new Map<string, Solution[]>();

function getCacheKey(region: Region): string {
  return `${region.id}_${region.type}_${JSON.stringify(region.resource)}`;
}

async function getOptimalSolution(region: Region): Promise<Solution[]> {
  const cacheKey = getCacheKey(region);
  
  if (solutionCache.has(cacheKey)) {
    return solutionCache.get(cacheKey)!;
  }
  
  const solutions = await findOptimalSolution(region);
  solutionCache.set(cacheKey, solutions);
  
  return solutions;
}
```

### 5.3 增量更新

```typescript
// 当用户修改单个参数时，只重新计算受影响的部分
function incrementalUpdate(
  baseSolution: Solution,
  changedParam: string,
  newValue: number
): Solution {
  // 只重新仿真，不重新搜索
  const newConfig = { ...baseSolution.config };
  
  switch (changedParam) {
    case 'windCount':
      newConfig.wind = selectWindTurbines(newValue);
      break;
    case 'solarCount':
      newConfig.solar = selectSolarPanels(newValue);
      newConfig.inverter = selectInverters(newValue);
      break;
    // ... 其他参数
  }
  
  const simulation = simulate8760Hours(newConfig, baseSolution.region);
  
  return {
    config: newConfig,
    cost: calculateTotalCost(newConfig),
    reliability: simulation.reliability,
    curtailment: simulation.curtailmentRate,
    simulation
  };
}
```

---

## 六、搜索空间总结

| 区域类型 | 原始空间 | 优化后空间 | 压缩比 | 预计耗时 |
|---------|---------|-----------|-------|---------|
| 工业区 | 7500万 | 55,000 | 1364:1 | ~5秒 |
| 居民区 | 7500万 | 116,000 | 647:1 | ~10秒 |
| 山地区 | 7500万 | 49,000 | 1531:1 | ~4秒 |
| 农业区 | 7500万 | 65,000 | 1154:1 | ~6秒 |
| 林业区 | 7500万 | 49,000 | 1531:1 | ~4秒 |

**总结**：通过智能搜索范围估算，将搜索空间压缩了1000倍以上，使得在浏览器中实时计算成为可能。

---

## 七、实现优先级

1. **P0 - 核心功能**
   - 搜索范围估算算法
   - 8760小时仿真引擎
   - 设备自动选型

2. **P1 - 性能优化**
   - Web Worker并行计算
   - 结果缓存

3. **P2 - 用户体验**
   - 进度显示
   - 增量更新
   - 结果可视化

---

*文档版本：v1.0*
*创建日期：2024年*
